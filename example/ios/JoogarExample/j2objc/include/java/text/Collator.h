//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/text/Collator.java
//

#ifndef _JavaTextCollator_H_
#define _JavaTextCollator_H_

#include "J2ObjC_header.h"
#include "java/util/Comparator.h"

@class IOSObjectArray;
@class JavaTextCollationKey;
@class JavaUtilLocale;

#define JavaTextCollator_NO_DECOMPOSITION 0
#define JavaTextCollator_CANONICAL_DECOMPOSITION 1
#define JavaTextCollator_FULL_DECOMPOSITION 2
#define JavaTextCollator_PRIMARY 0
#define JavaTextCollator_SECONDARY 1
#define JavaTextCollator_TERTIARY 2
#define JavaTextCollator_IDENTICAL 3

/*!
 @brief Performs locale-sensitive string comparison.
 <p>
 Following the <a href=http://www.unicode.org>Unicode Consortium</a>'s
 specifications for the <a
 href="http://www.unicode.org/unicode/reports/tr10/"> Unicode Collation
 Algorithm (UCA)</a>, there are 4 different levels of strength used in
 comparisons:
 <ul>
 <li>PRIMARY strength: Typically, this is used to denote differences between
 base characters (for example, "a" &lt; "b"). It is the strongest difference.
 For example, dictionaries are divided into different sections by base
 character.
 <li>SECONDARY strength: Accents in the characters are considered secondary
 differences (for example, "as" &lt; "&agrave;s" &lt; "at"). Other differences
 between letters can also be considered secondary differences, depending on
 the language. A secondary difference is ignored when there is a primary
 difference anywhere in the strings.
 <li>TERTIARY strength: Upper and lower case differences in characters are
 distinguished at tertiary strength (for example, "ao" &lt; "Ao" &lt;
 "a&ograve;"). In addition, a variant of a letter differs from the base form
 on the tertiary strength (such as "A" and "&#9398;"). Another example is the
 difference between large and small Kana. A tertiary difference is ignored
 when there is a primary or secondary difference anywhere in the strings.
 <li>IDENTICAL strength: When all other strengths are equal, the IDENTICAL
 strength is used as a tiebreaker. The Unicode code point values of the NFD
 form of each string are compared, just in case there is no difference. For
 example, Hebrew cantellation marks are only distinguished at this strength.
 This strength should be used sparingly, as only code point value differences
 between two strings are an extremely rare occurrence. Using this strength
 substantially decreases the performance for both comparison and collation key
 generation APIs. This strength also increases the size of the collation key.
 </ul>
 <p>
 This <code>Collator</code> deals only with two decomposition modes, the canonical
 decomposition mode and one that does not use any decomposition. The
 compatibility decomposition mode
 <code>java.text.Collator.FULL_DECOMPOSITION</code> is not supported here. If the
 canonical decomposition mode is set, <code>Collator</code> handles un-normalized
 text properly, producing the same results as if the text were normalized in
 NFD. If canonical decomposition is turned off, it is the user's
 responsibility to ensure that all text is already in the appropriate form
 before performing a comparison or before getting a <code>CollationKey</code>.
 <p>
 <em>Examples:</em>
 <blockquote>
 @code

  // Get the Collator for US English and set its strength to PRIMARY
  Collator usCollator = Collator.getInstance(Locale.US);
  usCollator.setStrength(Collator.PRIMARY);
  if (usCollator.compare(&quot;abc&quot;, &quot;ABC&quot;) == 0) {
     System.out.println(&quot;Strings are equivalent&quot;);
  }
  
@endcode
 </blockquote>
 <p>
 The following example shows how to compare two strings using the collator for
 the default locale.
 <blockquote>
 @code

  // Compare two strings in the default locale
  Collator myCollator = Collator.getInstance();
  myCollator.setDecomposition(Collator.NO_DECOMPOSITION);
  if (myCollator.compare(&quot;\u00e0\u0325&quot;, &quot;a\u0325\u0300&quot;) != 0) {
     System.out.println(&quot;\u00e0\u0325 is not equal to a\u0325\u0300 without decomposition&quot;);
     myCollator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);
     if (myCollator.compare(&quot;\u00e0\u0325&quot;, &quot;a\u0325\u0300&quot;) != 0) {
         System.out.println(&quot;Error: \u00e0\u0325 should be equal to a\u0325\u0300 with decomposition&quot;);
     } else {
         System.out.println(&quot;\u00e0\u0325 is equal to a\u0325\u0300 with decomposition&quot;);
     }
  } else {
     System.out.println(&quot;Error: \u00e0\u0325 should be not equal to a\u0325\u0300 without decomposition&quot;);
  }
  
@endcode
 </blockquote>
 */
@interface JavaTextCollator : NSObject < JavaUtilComparator, NSCopying >

#pragma mark Public

- (instancetype)init;

- (id)clone;

/*!
 @brief Compares two objects to determine their relative order.
 The objects must
 be strings.
 @param object1
 the first string to compare.
 @param object2
 the second string to compare.
 @return a negative value if <code>object1</code> is less than <code>object2</code>,
 0 if they are equal, and a positive value if <code>object1</code> is
 greater than <code>object2</code>.
 @throws ClassCastException
 if <code>object1</code> or <code>object2</code> is not a <code>String</code>.
 */
- (jint)compareWithId:(id)object1
               withId:(id)object2;

/*!
 @brief Compares two strings to determine their relative order.
 @param string1
 the first string to compare.
 @param string2
 the second string to compare.
 @return a negative value if <code>string1</code> is less than <code>string2</code>,
 0 if they are equal and a positive value if <code>string1</code> is
 greater than <code>string2</code>.
 */
- (jint)compareWithNSString:(NSString *)string1
               withNSString:(NSString *)string2;

/*!
 @brief Compares two strings using the collation rules to determine if they are
 equal.
 @param string1
 the first string to compare.
 @param string2
 the second string to compare.
 @return <code>true</code> if <code>string1</code> and <code>string2</code> are equal
 using the collation rules, false otherwise.
 */
- (jboolean)equalsWithNSString:(NSString *)string1
                  withNSString:(NSString *)string2;

/*!
 @brief Returns an array of locales for which custom <code>Collator</code> instances
 are available.
 <p>Note that Android does not support user-supplied locale service providers.
 */
+ (IOSObjectArray *)getAvailableLocales;

/*!
 @brief Returns a <code>CollationKey</code> for the specified string for this collator
 with the current decomposition rule and strength value.
 @param string
 the source string that is converted into a collation key.
 @return the collation key for <code>string</code>.
 */
- (JavaTextCollationKey *)getCollationKeyWithNSString:(NSString *)string;

/*!
 @brief Returns the decomposition rule for this collator.
 @return the decomposition rule, either <code>NO_DECOMPOSITION</code> or
 <code>CANONICAL_DECOMPOSITION</code>. <code>FULL_DECOMPOSITION</code> is
 not supported.
 */
- (jint)getDecomposition;

/*!
 @brief Returns a <code>Collator</code> instance which is appropriate for the user's default
 <code>Locale</code>.
 See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
 */
+ (JavaTextCollator *)getInstance;

/*!
 @brief Returns a <code>Collator</code> instance which is appropriate for <code>locale</code>.
 */
+ (JavaTextCollator *)getInstanceWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the strength value for this collator.
 @return the strength value, either PRIMARY, SECONDARY, TERTIARY or
 IDENTICAL.
 */
- (jint)getStrength;

/*!
 @brief Sets the decomposition rule for this collator.
 @param value
 the decomposition rule, either <code>NO_DECOMPOSITION</code> or
 <code>CANONICAL_DECOMPOSITION</code>. <code>FULL_DECOMPOSITION</code>
 is not supported.
 @throws IllegalArgumentException
 if the provided decomposition rule is not valid. This includes
 <code>FULL_DECOMPOSITION</code>.
 */
- (void)setDecompositionWithInt:(jint)value;

/*!
 @brief Sets the strength value for this collator.
 @param value
 the strength value, either PRIMARY, SECONDARY, TERTIARY, or
 IDENTICAL.
 @throws IllegalArgumentException
 if the provided strength value is not valid.
 */
- (void)setStrengthWithInt:(jint)value;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextCollator)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, NO_DECOMPOSITION, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, CANONICAL_DECOMPOSITION, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, FULL_DECOMPOSITION, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, PRIMARY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, SECONDARY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, TERTIARY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaTextCollator, IDENTICAL, jint)

FOUNDATION_EXPORT IOSObjectArray *JavaTextCollator_getAvailableLocales();

FOUNDATION_EXPORT JavaTextCollator *JavaTextCollator_getInstance();

FOUNDATION_EXPORT JavaTextCollator *JavaTextCollator_getInstanceWithJavaUtilLocale_(JavaUtilLocale *locale);

FOUNDATION_EXPORT void JavaTextCollator_init(JavaTextCollator *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextCollator)

#endif // _JavaTextCollator_H_
