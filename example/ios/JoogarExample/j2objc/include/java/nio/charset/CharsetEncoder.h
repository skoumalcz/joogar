//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/charset/CharsetEncoder.java
//

#ifndef _JavaNioCharsetCharsetEncoder_H_
#define _JavaNioCharsetCharsetEncoder_H_

#include "J2ObjC_header.h"

@class IOSByteArray;
@class JavaNioByteBuffer;
@class JavaNioCharBuffer;
@class JavaNioCharsetCharset;
@class JavaNioCharsetCoderResult;
@class JavaNioCharsetCodingErrorAction;
@protocol JavaLangCharSequence;

/*!
 @brief Transforms a sequence of 16-bit Java characters to a byte sequence in some encoding.
 <p>The input character sequence is a <code>CharBuffer</code> and the
 output byte sequence is a <code>ByteBuffer</code>.
 <p>Use <code>encode(CharBuffer)</code> to encode an entire <code>CharBuffer</code> to a
 new <code>ByteBuffer</code>, or <code>encode(CharBuffer,ByteBuffer,boolean)</code> for more
 control. When using the latter method, the entire operation proceeds as follows:
 <ol>
 <li>Invoke <code>reset()</code> to reset the encoder if this instance has been used before.</li>
 <li>Invoke <code>encode</code> with the <code>endOfInput</code>
 parameter set to false until additional input is not needed (as signaled by the return value).
 The input buffer must be filled and the output buffer must be flushed between invocations.
 <p>The <code>encode</code> method will
 convert as many characters as possible, and the process won't stop until the
 input buffer has been exhausted, the output buffer has been filled, or an
 error has occurred. A <code>CoderResult</code> instance will be
 returned to indicate the current state. The caller should fill the input buffer, flush
 the output buffer, or recovering from an error and try again, accordingly.
 </li>
 <li>Invoke <code>encode</code> for the last time with
 <code>endOfInput</code> set to true.</li>
 <li>Invoke <code>flush(ByteBuffer)</code> to flush remaining output.</li>
 </ol>
 <p>There are two classes of encoding error: <i>malformed input</i>
 signifies that the input character sequence is not legal, while <i>unmappable character</i>
 signifies that the input is legal but cannot be mapped to a byte sequence (because the charset
 cannot represent the character, for example).
 <p>Errors can be handled in three ways. The default is to
 <code>report</code> the error to the caller. The alternatives are to
 <code>ignore</code> the error or <code>replace</code>
 the problematic input with the byte sequence returned by <code>replacement</code>. The disposition
 for each of the two kinds of error can be set independently using the <code>onMalformedInput</code>
 and <code>onUnmappableCharacter</code> methods.
 <p>The default replacement bytes depend on the charset but can be overridden using the
 <code>replaceWith</code> method.
 <p>This class is abstract and encapsulates many common operations of the
 encoding process for all charsets. Encoders for a specific charset should
 extend this class and need only to implement the
 <code>encodeLoop</code> method for basic
 encoding.
 <p>This class is not thread-safe.
 */
@interface JavaNioCharsetCharsetEncoder : NSObject

#pragma mark Public

/*!
 @brief Returns the average number of bytes created by this encoder for a single
 input character.
 */
- (jfloat)averageBytesPerChar;

/*!
 @brief Checks if the given character can be encoded by this encoder.
 <p>
 Note that this method can change the internal status of this encoder, so
 it should not be called when another encoding process is ongoing,
 otherwise it will throw an <code>IllegalStateException</code>.
 <p>
 This method can be overridden for performance improvement.
 @param c
 the given encoder.
 @return true if given character can be encoded by this encoder.
 @throws IllegalStateException
 if another encode process is ongoing so that the current
 internal status is neither RESET or FLUSH.
 */
- (jboolean)canEncodeWithChar:(jchar)c;

/*!
 @brief Checks if a given <code>CharSequence</code> can be encoded by this
 encoder.
 Note that this method can change the internal status of this encoder, so
 it should not be called when another encode process is ongoing, otherwise
 it will throw an <code>IllegalStateException</code>.
 This method can be overridden for performance improvement.
 @param sequence
 the given <code>CharSequence</code>.
 @return true if the given <code>CharSequence</code> can be encoded by
 this encoder.
 @throws IllegalStateException
 if current internal status is neither RESET or FLUSH.
 */
- (jboolean)canEncodeWithJavaLangCharSequence:(id<JavaLangCharSequence>)sequence;

/*!
 @brief Returns the <code>Charset</code> which this encoder uses.
 */
- (JavaNioCharsetCharset *)charset;

/*!
 @brief This is a facade method for the encoding operation.
 <p>
 This method encodes the remaining character sequence of the given
 character buffer into a new byte buffer. This method performs a complete
 encoding operation, resets at first, then encodes, and flushes at last.
 <p>
 This method should not be invoked if another encode operation is ongoing.
 @param inArg
 the input buffer.
 @return a new <code>ByteBuffer</code> containing the bytes produced by
 this encoding operation. The buffer's limit will be the position
 of the last byte in the buffer, and the position will be zero.
 @throws IllegalStateException
 if another encoding operation is ongoing.
 @throws MalformedInputException
 if an illegal input character sequence for this charset is
 encountered, and the action for malformed error is
 <code>CodingErrorAction.REPORT</code>
 @throws UnmappableCharacterException
 if a legal but unmappable input character sequence for this
 charset is encountered, and the action for unmappable
 character error is
 <code>CodingErrorAction.REPORT</code>.
 Unmappable means the Unicode character sequence at the input
 buffer's current position cannot be mapped to a equivalent
 byte sequence.
 @throws CharacterCodingException
 if other exception happened during the encode operation.
 */
- (JavaNioByteBuffer *)encodeWithJavaNioCharBuffer:(JavaNioCharBuffer *)inArg;

/*!
 @brief Encodes characters starting at the current position of the given input
 buffer, and writes the equivalent byte sequence into the given output
 buffer from its current position.
 <p>
 The buffers' position will be changed with the reading and writing
 operation, but their limits and marks will be kept intact.
 <p>
 A <code>CoderResult</code> instance will be returned according to
 following rules:
 <ul>
 <li>A <code>malformed input</code> result
 indicates that some malformed input error was encountered, and the
 erroneous characters start at the input buffer's position and their
 number can be got by result's <code>length</code>. This
 kind of result can be returned only if the malformed action is
 <code>CodingErrorAction.REPORT</code>.</li>
 <li><code>CoderResult.UNDERFLOW</code> indicates that
 as many characters as possible in the input buffer have been encoded. If
 there is no further input and no characters left in the input buffer then
 this task is complete. If this is not the case then the client should
 call this method again supplying some more input characters.</li>
 <li><code>CoderResult.OVERFLOW</code> indicates that the
 output buffer has been filled, while there are still some characters
 remaining in the input buffer. This method should be invoked again with a
 non-full output buffer.</li>
 <li>A <code>unmappable character</code>
 result indicates that some unmappable character error was encountered,
 and the erroneous characters start at the input buffer's position and
 their number can be got by result's <code>length</code>.
 This kind of result can be returned only on
 <code>CodingErrorAction.REPORT</code>.</li>
 </ul>
 <p>
 The <code>endOfInput</code> parameter indicates if the invoker can
 provider further input. This parameter is true if and only if the
 characters in the current input buffer are all inputs for this encoding
 operation. Note that it is common and won't cause an error if the invoker
 sets false and then has no more input available, while it may cause an
 error if the invoker always sets true in several consecutive invocations.
 This would make the remaining input to be treated as malformed input.
 input.
 <p>
 This method invokes the
 <code>encodeLoop</code> method to
 implement the basic encode logic for a specific charset.
 @param inArg
 the input buffer.
 @param outArg
 the output buffer.
 @param endOfInput
 true if all the input characters have been provided.
 @return a <code>CoderResult</code> instance indicating the result.
 @throws IllegalStateException
 if the encoding operation has already started or no more
 input is needed in this encoding process.
 @throws CoderMalfunctionError
 If the <code>encodeLoop</code>
 method threw an <code>BufferUnderflowException</code> or
 <code>BufferUnderflowException</code>.
 */
- (JavaNioCharsetCoderResult *)encodeWithJavaNioCharBuffer:(JavaNioCharBuffer *)inArg
                                     withJavaNioByteBuffer:(JavaNioByteBuffer *)outArg
                                               withBoolean:(jboolean)endOfInput;

/*!
 @brief Flushes this encoder.
 <p>
 The maximum number of written bytes won't larger than
 <code>out.remaining()</code>. If some encoder wants to
 write more bytes than the output buffer's available remaining space, then
 <code>CoderResult.OVERFLOW</code> will be returned, and this method
 must be called again with a byte buffer that has free space. Otherwise
 this method will return <code>CoderResult.UNDERFLOW</code>, which
 means one encoding process has been completed successfully.
 <p>
 During the flush, the output buffer's position will be changed
 accordingly, while its mark and limit will be intact.
 @param outArg
 the given output buffer.
 @return <code>CoderResult.UNDERFLOW</code> or
 <code>CoderResult.OVERFLOW</code>.
 @throws IllegalStateException
 if this encoder hasn't read all input characters during one
 encoding process, which means neither after calling
 <code>encode(CharBuffer)</code> nor after
 calling <code>encode(CharBuffer, ByteBuffer, boolean)</code>
  with <code>true</code>
 for the last boolean parameter.
 */
- (JavaNioCharsetCoderResult *)flushWithJavaNioByteBuffer:(JavaNioByteBuffer *)outArg;

/*!
 @brief Returns this encoder's <code>CodingErrorAction</code> when a malformed
 input error occurred during the encoding process.
 */
- (JavaNioCharsetCodingErrorAction *)malformedInputAction;

/*!
 @brief Returns the maximum number of bytes which can be created by this encoder for
 one input character, must be positive.
 */
- (jfloat)maxBytesPerChar;

/*!
 @brief Sets this encoder's action on malformed input error.
 @param newAction
 the new action on malformed input error.
 @return this encoder.
 @throws IllegalArgumentException
 if the given newAction is null.
 */
- (JavaNioCharsetCharsetEncoder *)onMalformedInputWithJavaNioCharsetCodingErrorAction:(JavaNioCharsetCodingErrorAction *)newAction;

/*!
 @brief Sets this encoder's action on unmappable character error.
 @param newAction
 the new action on unmappable character error.
 @return this encoder.
 @throws IllegalArgumentException
 if the given newAction is null.
 */
- (JavaNioCharsetCharsetEncoder *)onUnmappableCharacterWithJavaNioCharsetCodingErrorAction:(JavaNioCharsetCodingErrorAction *)newAction;

/*!
 @brief Returns the replacement byte array, which is never null or empty.
 */
- (IOSByteArray *)replacement;

/*!
 @brief Sets the new replacement value.
 This method first checks the given replacement's validity, then changes
 the replacement value.
 @param replacement
 the replacement byte array, cannot be null or empty, its
 length cannot be larger than <code>maxBytesPerChar</code>,
 and it must be legal replacement.
 @return this encoder.
 @throws IllegalArgumentException
 if the given replacement cannot satisfy the requirement
 mentioned above.
 */
- (JavaNioCharsetCharsetEncoder *)replaceWithWithByteArray:(IOSByteArray *)replacement;

/*!
 @brief Resets this encoder.
 @return this encoder.
 */
- (JavaNioCharsetCharsetEncoder *)reset;

/*!
 @brief Returns this encoder's <code>CodingErrorAction</code> when unmappable
 character occurred during encoding process.
 */
- (JavaNioCharsetCodingErrorAction *)unmappableCharacterAction;

#pragma mark Protected

/*!
 @brief Constructs a new <code>CharsetEncoder</code> using the given parameters and
 the replacement byte array <code></code> (byte) '?'
 }}.
 */
- (instancetype)initWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs
                                    withFloat:(jfloat)averageBytesPerChar
                                    withFloat:(jfloat)maxBytesPerChar;

/*!
 @brief Constructs a new <code>CharsetEncoder</code> using the given
 <code>Charset</code>, replacement byte array, average number and
 maximum number of bytes created by this encoder for one input character.
 @param cs
 the <code>Charset</code> to be used by this encoder.
 @param averageBytesPerChar
 average number of bytes created by this encoder for one single
 input character, must be positive.
 @param maxBytesPerChar
 maximum number of bytes which can be created by this encoder
 for one single input character, must be positive.
 @param replacement
 the replacement byte array, cannot be null or empty, its
 length cannot be larger than <code>maxBytesPerChar</code>,
 and must be a legal replacement.
 @throws IllegalArgumentException
 if any parameters are invalid.
 */
- (instancetype)initWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs
                                    withFloat:(jfloat)averageBytesPerChar
                                    withFloat:(jfloat)maxBytesPerChar
                                withByteArray:(IOSByteArray *)replacement;

/*!
 @brief Encodes characters into bytes.
 This method is called by
 <code>encode</code>.
 <p>
 This method will implement the essential encoding operation, and it won't
 stop encoding until either all the input characters are read, the output
 buffer is filled, or some exception is encountered. Then it will
 return a <code>CoderResult</code> object indicating the result of the
 current encoding operation. The rule to construct the
 <code>CoderResult</code> is the same as for
 <code>encode</code>. When an
 exception is encountered in the encoding operation, most implementations
 of this method will return a relevant result object to the
 <code>encode</code> method, and some
 performance optimized implementation may handle the exception and
 implement the error action itself.
 <p>
 The buffers are scanned from their current positions, and their positions
 will be modified accordingly, while their marks and limits will be
 intact. At most <code>in.remaining()</code> characters
 will be read, and <code>out.remaining()</code> bytes
 will be written.
 <p>
 Note that some implementations may pre-scan the input buffer and return
 <code>CoderResult.UNDERFLOW</code> until it receives sufficient input.
 <p>
 @param inArg
 the input buffer.
 @param outArg
 the output buffer.
 @return a <code>CoderResult</code> instance indicating the result.
 */
- (JavaNioCharsetCoderResult *)encodeLoopWithJavaNioCharBuffer:(JavaNioCharBuffer *)inArg
                                         withJavaNioByteBuffer:(JavaNioByteBuffer *)outArg;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioCharsetCharsetEncoder)

FOUNDATION_EXPORT void JavaNioCharsetCharsetEncoder_initWithJavaNioCharsetCharset_withFloat_withFloat_(JavaNioCharsetCharsetEncoder *self, JavaNioCharsetCharset *cs, jfloat averageBytesPerChar, jfloat maxBytesPerChar);

FOUNDATION_EXPORT void JavaNioCharsetCharsetEncoder_initWithJavaNioCharsetCharset_withFloat_withFloat_withByteArray_(JavaNioCharsetCharsetEncoder *self, JavaNioCharsetCharset *cs, jfloat averageBytesPerChar, jfloat maxBytesPerChar, IOSByteArray *replacement);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioCharsetCharsetEncoder)

#endif // _JavaNioCharsetCharsetEncoder_H_
