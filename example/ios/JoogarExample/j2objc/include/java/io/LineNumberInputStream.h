//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/LineNumberInputStream.java
//

#ifndef _JavaIoLineNumberInputStream_H_
#define _JavaIoLineNumberInputStream_H_

#include "J2ObjC_header.h"
#include "java/io/FilterInputStream.h"

@class IOSByteArray;
@class JavaIoInputStream;

/*!
 @brief Wraps an existing <code>InputStream</code> and counts the line terminators
 encountered while reading the data.
 Line numbering starts at 0. Recognized
 line terminator sequences are <code>'\r'</code>, <code>'\n'</code> and <code>"\r\n"</code>.
 When using <code>read</code>, line terminator sequences are always translated into
 <code>'\n'</code>.
 */
@interface JavaIoLineNumberInputStream : JavaIoFilterInputStream

#pragma mark Public

/*!
 @brief Constructs a new <code>LineNumberInputStream</code> on the <code>InputStream</code>
 <code>in</code>.
 Line numbers are counted for all data read from this stream.
 <p><strong>Warning:</strong> passing a null source creates an invalid
 <code>LineNumberInputStream</code>. All operations on such a stream will fail.
 @param inArg
 The non-null input stream to count line numbers.
 */
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg;

/*!
 @brief 
 <p>Note that the source stream may just be a sequence of <code>"\r\n"</code> bytes
 which are converted into <code>'\n'</code> by this stream.
 Therefore,
 <code>available</code> returns only <code>in.available() / 2</code> bytes as
 result.
 */
- (jint)available;

/*!
 @brief Returns the current line number for this stream.
 Numbering starts at 0.
 @return the current line number.
 */
- (jint)getLineNumber;

/*!
 @brief Sets a mark position in this stream.
 The parameter <code>readlimit</code>
 indicates how many bytes can be read before the mark is invalidated.
 Sending <code>reset()</code> will reposition this stream back to the marked
 position, provided that <code>readlimit</code> has not been surpassed.
 The line number count will also be reset to the last marked
 line number count.
 <p>
 This implementation sets a mark in the filtered stream.
 @param readlimit
 the number of bytes that can be read from this stream before
 the mark is invalidated.
 */
- (void)markWithInt:(jint)readlimit;

/*!
 @brief Reads a single byte from the filtered stream and returns it as an integer
 in the range from 0 to 255.
 Returns -1 if the end of this stream has been
 reached.
 <p>
 The line number count is incremented if a line terminator is encountered.
 Recognized line terminator sequences are <code>'\r'</code>, <code>'\n'</code> and
 <code>"\r\n"</code>. Line terminator sequences are always translated into
 <code>'\n'</code>.
 @return the byte read or -1 if the end of the filtered stream has been
 reached.
 @throws IOException
 if the stream is closed or another IOException occurs.
 */
- (jint)read;

/*!
 @brief Reads up to <code>byteCount</code> bytes from the filtered stream and stores
 them in the byte array <code>buffer</code> starting at <code>byteOffset</code>.
 Returns the number of bytes actually read or -1 if no bytes have been
 read and the end of this stream has been reached.
 <p>The line number count is incremented if a line terminator is encountered.
 Recognized line terminator sequences are <code>'\r'</code>, <code>'\n'</code> and
 <code>"\r\n"</code>. Line terminator sequences are always translated into
 <code>'\n'</code>.
 @throws IndexOutOfBoundsException
 if <code>byteOffset < 0 || byteCount < 0 || byteOffset + byteCount > buffer.length</code>.
 @throws IOException
 if this stream is closed or another IOException occurs.
 @throws NullPointerException
 if <code>buffer == null</code>.
 */
- (jint)readWithByteArray:(IOSByteArray *)buffer
                  withInt:(jint)byteOffset
                  withInt:(jint)byteCount;

/*!
 @brief Resets this stream to the last marked location.
 It also resets the line
 count to what is was when this stream was marked.
 @throws IOException
 if this stream is already closed, no mark has been set or the
 mark is no longer valid because more than <code>readlimit</code>
 bytes have been read since setting the mark.
 */
- (void)reset;

/*!
 @brief Sets the line number of this stream to the specified
 <code>lineNumber</code>.
 Note that this may have side effects on the
 line number associated with the last marked position.
 @param lineNumber
 the new lineNumber value.
 */
- (void)setLineNumberWithInt:(jint)lineNumber;

/*!
 @brief Skips <code>count</code> number of bytes in this stream.
 Subsequent
 calls to <code>read</code> will not return these bytes unless <code>reset</code> is
 used. This implementation skips <code>byteCount</code> bytes in the
 filtered stream and increments the line number count whenever line
 terminator sequences are skipped.
 @param byteCount
 the number of bytes to skip.
 @return the number of bytes actually skipped.
 @throws IOException
 if this stream is closed or another IOException occurs.
 */
- (jlong)skipWithLong:(jlong)byteCount;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoLineNumberInputStream)

FOUNDATION_EXPORT void JavaIoLineNumberInputStream_initWithJavaIoInputStream_(JavaIoLineNumberInputStream *self, JavaIoInputStream *inArg);

FOUNDATION_EXPORT JavaIoLineNumberInputStream *new_JavaIoLineNumberInputStream_initWithJavaIoInputStream_(JavaIoInputStream *inArg) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoLineNumberInputStream)

#endif // _JavaIoLineNumberInputStream_H_
