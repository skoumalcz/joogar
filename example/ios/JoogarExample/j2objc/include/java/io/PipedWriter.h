//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/PipedWriter.java
//

#ifndef _JavaIoPipedWriter_H_
#define _JavaIoPipedWriter_H_

#include "J2ObjC_header.h"
#include "java/io/Writer.h"

@class IOSCharArray;
@class JavaIoPipedReader;

/*!
 @brief Places information on a communications pipe.
 When two threads want to pass
 data back and forth, one creates a piped writer and the other creates a piped
 reader.
 */
@interface JavaIoPipedWriter : JavaIoWriter

#pragma mark Public

/*!
 @brief Constructs a new unconnected <code>PipedWriter</code>.
 The resulting writer
 must be connected to a <code>PipedReader</code> before data may be written to
 it.
 */
- (instancetype)init;

/*!
 @brief Constructs a new <code>PipedWriter</code> connected to <code>destination</code>.
 Any data written to this writer can be read from <code>destination</code>.
 @param destination
 the <code>PipedReader</code> to connect to.
 @throws IOException
 if <code>destination</code> is already connected.
 */
- (instancetype)initWithJavaIoPipedReader:(JavaIoPipedReader *)destination;

/*!
 @brief Closes this writer.
 If a <code>PipedReader</code> is connected to this writer,
 it is closed as well and the pipe is disconnected. Any data buffered in
 the reader can still be read.
 @throws IOException
 if an error occurs while closing this writer.
 */
- (void)close;

/*!
 @brief Connects this <code>PipedWriter</code> to a <code>PipedReader</code>.
 Any data
 written to this writer becomes readable in the reader.
 @param reader
 the reader to connect to.
 @throws IOException
 if this writer is closed or already connected, or if <code>reader</code>
  is already connected.
 */
- (void)connectWithJavaIoPipedReader:(JavaIoPipedReader *)reader;

/*!
 @brief Notifies the readers of this <code>PipedReader</code> that characters can be read.
 This
 method does nothing if this Writer is not connected.
 @throws IOException
 if an I/O error occurs while flushing this writer.
 */
- (void)flush;

/*!
 @brief Writes <code>count</code> characters from the character array <code>buffer</code>
 starting at offset <code>index</code> to this writer.
 The written data can
 then be read from the connected <code>PipedReader</code> instance.
 <p>
 Separate threads should be used to write to a <code>PipedWriter</code> and to
 read from the connected <code>PipedReader</code>. If the same thread is used,
 a deadlock may occur.
 @param buffer
 the buffer to write.
 @param offset
 the index of the first character in <code>buffer</code> to write.
 @param count
 the number of characters from <code>buffer</code> to write to this
 writer.
 @throws IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>count < 0</code>, or if <code>offset + count</code>
  is bigger than the length of <code>buffer</code>.
 @throws InterruptedIOException
 if the pipe is full and the current thread is interrupted
 waiting for space to write data. This case is not currently
 handled correctly.
 @throws IOException
 if this writer is closed or not connected, if the target
 reader is closed or if the thread reading from the target
 reader is no longer alive. This case is currently not handled
 correctly.
 @throws NullPointerException
 if <code>buffer</code> is <code>null</code>.
 */
- (void)writeWithCharArray:(IOSCharArray *)buffer
                   withInt:(jint)offset
                   withInt:(jint)count;

/*!
 @brief Writes a single character <code>c</code> to this writer.
 This character can
 then be read from the connected <code>PipedReader</code> instance.
 <p>
 Separate threads should be used to write to a <code>PipedWriter</code> and to
 read from the connected <code>PipedReader</code>. If the same thread is used,
 a deadlock may occur.
 @param c
 the character to write.
 @throws InterruptedIOException
 if the pipe is full and the current thread is interrupted
 waiting for space to write data. This case is not currently
 handled correctly.
 @throws IOException
 if this writer is closed or not connected, if the target
 reader is closed or if the thread reading from the target
 reader is no longer alive. This case is currently not handled
 correctly.
 */
- (void)writeWithInt:(jint)c;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoPipedWriter)

FOUNDATION_EXPORT void JavaIoPipedWriter_init(JavaIoPipedWriter *self);

FOUNDATION_EXPORT JavaIoPipedWriter *new_JavaIoPipedWriter_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoPipedWriter_initWithJavaIoPipedReader_(JavaIoPipedWriter *self, JavaIoPipedReader *destination);

FOUNDATION_EXPORT JavaIoPipedWriter *new_JavaIoPipedWriter_initWithJavaIoPipedReader_(JavaIoPipedReader *destination) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoPipedWriter)

#endif // _JavaIoPipedWriter_H_
