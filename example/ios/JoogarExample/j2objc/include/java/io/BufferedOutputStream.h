//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/BufferedOutputStream.java
//

#ifndef _JavaIoBufferedOutputStream_H_
#define _JavaIoBufferedOutputStream_H_

#include "J2ObjC_header.h"
#include "java/io/FilterOutputStream.h"

@class IOSByteArray;
@class JavaIoOutputStream;

/*!
 @brief Wraps an existing <code>OutputStream</code> and <em>buffers</em> the output.
 Expensive interaction with the underlying input stream is minimized, since
 most (smaller) requests can be satisfied by accessing the buffer alone. The
 drawback is that some extra space is required to hold the buffer and that
 copying takes place when flushing that buffer, but this is usually outweighed
 by the performance benefits.
 <p/>A typical application pattern for the class looks like this:<p/>
 @code

  BufferedOutputStream buf = new BufferedOutputStream(new FileOutputStream(&quot;file.java&quot;));
  
@endcode
 */
@interface JavaIoBufferedOutputStream : JavaIoFilterOutputStream {
 @public
  /*!
   @brief The buffer containing the bytes to be written to the target stream.
   */
  IOSByteArray *buf_;
  /*!
   @brief The total number of bytes inside the byte array <code>buf</code>.
   */
  jint count_;
}

#pragma mark Public

/*!
 @brief Constructs a new <code>BufferedOutputStream</code>, providing <code>out</code> with a buffer
 of 8192 bytes.
 @param outArg the <code>OutputStream</code> the buffer writes to.
 */
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg;

/*!
 @brief Constructs a new <code>BufferedOutputStream</code>, providing <code>out</code> with <code>size</code> bytes
 of buffer.
 @param outArg the <code>OutputStream</code> the buffer writes to.
 @param size the size of buffer in bytes.
 @throws IllegalArgumentException if <code>size <= 0</code>.
 */
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                   withInt:(jint)size;

- (void)close;

/*!
 @brief Flushes this stream to ensure all pending data is written out to the
 target stream.
 In addition, the target stream is flushed.
 @throws IOException
 if an error occurs attempting to flush this stream.
 */
- (void)flush;

/*!
 @brief Writes <code>count</code> bytes from the byte array <code>buffer</code> starting at
 <code>offset</code> to this stream.
 If there is room in the buffer to hold the
 bytes, they are copied in. If not, the buffered bytes plus the bytes in
 <code>buffer</code> are written to the target stream, the target is flushed,
 and the buffer is cleared.
 @param buffer
 the buffer to be written.
 @param offset
 the start position in <code>buffer</code> from where to get bytes.
 @param length
 the number of bytes from <code>buffer</code> to write to this
 stream.
 @throws IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>length < 0</code>, or if
 <code>offset + length</code> is greater than the size of
 <code>buffer</code>.
 @throws IOException
 if an error occurs attempting to write to this stream.
 @throws NullPointerException
 if <code>buffer</code> is <code>null</code>.
 @throws ArrayIndexOutOfBoundsException
 If offset or count is outside of bounds.
 */
- (void)writeWithByteArray:(IOSByteArray *)buffer
                   withInt:(jint)offset
                   withInt:(jint)length;

/*!
 @brief Writes one byte to this stream.
 Only the low order byte of the integer
 <code>oneByte</code> is written. If there is room in the buffer, the byte is
 copied into the buffer and the count incremented. Otherwise, the buffer
 plus <code>oneByte</code> are written to the target stream, the target is
 flushed, and the buffer is reset.
 @param oneByte
 the byte to be written.
 @throws IOException
 if an error occurs attempting to write to this stream.
 */
- (void)writeWithInt:(jint)oneByte;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoBufferedOutputStream)

J2OBJC_FIELD_SETTER(JavaIoBufferedOutputStream, buf_, IOSByteArray *)

FOUNDATION_EXPORT void JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(JavaIoBufferedOutputStream *self, JavaIoOutputStream *outArg);

FOUNDATION_EXPORT JavaIoBufferedOutputStream *new_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(JavaIoOutputStream *outArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoBufferedOutputStream_initWithJavaIoOutputStream_withInt_(JavaIoBufferedOutputStream *self, JavaIoOutputStream *outArg, jint size);

FOUNDATION_EXPORT JavaIoBufferedOutputStream *new_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint size) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoBufferedOutputStream)

#endif // _JavaIoBufferedOutputStream_H_
