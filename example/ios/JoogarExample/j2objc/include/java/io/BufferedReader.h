//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/BufferedReader.java
//

#ifndef _JavaIoBufferedReader_H_
#define _JavaIoBufferedReader_H_

#include "J2ObjC_header.h"
#include "java/io/Reader.h"

@class IOSCharArray;

/*!
 @brief Wraps an existing <code>Reader</code> and <em>buffers</em> the input.
 Expensive
 interaction with the underlying reader is minimized, since most (smaller)
 requests can be satisfied by accessing the buffer alone. The drawback is that
 some extra space is required to hold the buffer and that copying takes place
 when filling that buffer, but this is usually outweighed by the performance
 benefits.
 <p/>A typical application pattern for the class looks like this:<p/>
 @code

  BufferedReader buf = new BufferedReader(new FileReader(&quot;file.java&quot;));
  
@endcode
 @since 1.1
 */
@interface JavaIoBufferedReader : JavaIoReader

#pragma mark Public

/*!
 @brief Constructs a new <code>BufferedReader</code>, providing <code>in</code> with a buffer
 of 8192 characters.
 @param inArg the <code>Reader</code> the buffer reads from.
 */
- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg;

/*!
 @brief Constructs a new <code>BufferedReader</code>, providing <code>in</code> with <code>size</code> characters
 of buffer.
 @param inArg the <code>InputStream</code> the buffer reads from.
 @param size the size of buffer in characters.
 @throws IllegalArgumentException if <code>size <= 0</code>.
 */
- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg
                             withInt:(jint)size;

/*!
 @brief Closes this reader.
 This implementation closes the buffered source reader
 and releases the buffer. Nothing is done if this reader has already been
 closed.
 @throws IOException
 if an error occurs while closing this reader.
 */
- (void)close;

/*!
 @brief Sets a mark position in this reader.
 The parameter <code>markLimit</code>
 indicates how many characters can be read before the mark is invalidated.
 Calling <code>reset()</code> will reposition the reader back to the marked
 position if <code>markLimit</code> has not been surpassed.
 @param markLimit
 the number of characters that can be read before the mark is
 invalidated.
 @throws IllegalArgumentException
 if <code>markLimit < 0</code>.
 @throws IOException
 if an error occurs while setting a mark in this reader.
 */
- (void)markWithInt:(jint)markLimit;

/*!
 @brief Indicates whether this reader supports the <code>mark()</code> and
 <code>reset()</code> methods.
 This implementation returns <code>true</code>.
 @return <code>true</code> for <code>BufferedReader</code>.
 */
- (jboolean)markSupported;

/*!
 @brief Reads a single character from this reader and returns it with the two
 higher-order bytes set to 0.
 If possible, BufferedReader returns a
 character from the buffer. If there are no characters available in the
 buffer, it fills the buffer and then returns a character. It returns -1
 if there are no more characters in the source reader.
 @return the character read or -1 if the end of the source reader has been
 reached.
 @throws IOException
 if this reader is closed or some other I/O error occurs.
 */
- (jint)read;

/*!
 @brief Reads up to <code>length</code> characters from this reader and stores them
 at <code>offset</code> in the character array <code>buffer</code>.
 Returns the
 number of characters actually read or -1 if the end of the source reader
 has been reached. If all the buffered characters have been used, a mark
 has not been set and the requested number of characters is larger than
 this readers buffer size, BufferedReader bypasses the buffer and simply
 places the results directly into <code>buffer</code>.
 @throws IndexOutOfBoundsException
 if <code>offset < 0 || length < 0 || offset + length > buffer.length</code>.
 @throws IOException
 if this reader is closed or some other I/O error occurs.
 */
- (jint)readWithCharArray:(IOSCharArray *)buffer
                  withInt:(jint)offset
                  withInt:(jint)length;

/*!
 @brief Returns the next line of text available from this reader.
 A line is
 represented by zero or more characters followed by <code>'\n'</code>,
 <code>'\r'</code>, <code>"\r\n"</code> or the end of the reader. The string does
 not include the newline sequence.
 @return the contents of the line or <code>null</code> if no characters were
 read before the end of the reader has been reached.
 @throws IOException
 if this reader is closed or some other I/O error occurs.
 */
- (NSString *)readLine;

/*!
 @brief Indicates whether this reader is ready to be read without blocking.
 @return <code>true</code> if this reader will not block when <code>read</code> is
 called, <code>false</code> if unknown or blocking will occur.
 @throws IOException
 if this reader is closed or some other I/O error occurs.
 */
- (jboolean)ready;

/*!
 @brief Resets this reader's position to the last <code>mark()</code> location.
 Invocations of <code>read()</code> and <code>skip()</code> will occur from this new
 location.
 @throws IOException
 if this reader is closed or no mark has been set.
 */
- (void)reset;

/*!
 @brief Skips at most <code>charCount</code> chars in this stream.
 Subsequent calls to
 <code>read</code> will not return these chars unless <code>reset</code> is
 used.
 <p>Skipping characters may invalidate a mark if <code>markLimit</code>
 is surpassed.
 @return the number of characters actually skipped.
 @throws IllegalArgumentException if <code>charCount < 0</code>.
 @throws IOException
 if this reader is closed or some other I/O error occurs.
 */
- (jlong)skipWithLong:(jlong)charCount;

#pragma mark Package-Private

/*!
 @brief Peeks at the next input character, refilling the buffer if necessary.
 If
 this character is a newline character ("\n"), it is discarded.
 */
- (void)chompNewline;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoBufferedReader)

FOUNDATION_EXPORT void JavaIoBufferedReader_initWithJavaIoReader_(JavaIoBufferedReader *self, JavaIoReader *inArg);

FOUNDATION_EXPORT JavaIoBufferedReader *new_JavaIoBufferedReader_initWithJavaIoReader_(JavaIoReader *inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoBufferedReader_initWithJavaIoReader_withInt_(JavaIoBufferedReader *self, JavaIoReader *inArg, jint size);

FOUNDATION_EXPORT JavaIoBufferedReader *new_JavaIoBufferedReader_initWithJavaIoReader_withInt_(JavaIoReader *inArg, jint size) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoBufferedReader)

#endif // _JavaIoBufferedReader_H_
