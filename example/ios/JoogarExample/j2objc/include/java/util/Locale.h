//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/Locale.java
//

#ifndef _JavaUtilLocale_H_
#define _JavaUtilLocale_H_

#include "J2ObjC_header.h"
#include "java/io/Serializable.h"

@class IOSObjectArray;

/*!
 @brief <code>Locale</code> represents a language/country/variant combination.
 Locales are used to
 alter the presentation of information such as numbers or dates to suit the conventions
 in the region they describe.
 <p>The language codes are two-letter lowercase ISO language codes (such as "en") as defined by
 <a href="http://en.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a>.
 The country codes are two-letter uppercase ISO country codes (such as "US") as defined by
 <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">ISO 3166-1</a>.
 The variant codes are unspecified.
 <p>Note that Java uses several deprecated two-letter codes. The Hebrew ("he") language
 code is rewritten as "iw", Indonesian ("id") as "in", and Yiddish ("yi") as "ji". This
 rewriting happens even if you construct your own <code>Locale</code> object, not just for
 instances returned by the various lookup methods.
 <a name="available_locales"><h3>Available locales</h3></a>
 <p>This class' constructors do no error checking. You can create a <code>Locale</code> for languages
 and countries that don't exist, and you can create instances for combinations that don't
 exist (such as "de_US" for "German as spoken in the US").
 <p>Note that locale data is not necessarily available for any of the locales pre-defined as
 constants in this class except for en_US, which is the only locale Java guarantees is always
 available.
 <p>It is also a mistake to assume that all devices have the same locales available.
 A device sold in the US will almost certainly support en_US and es_US, but not necessarily
 any locales with the same language but different countries (such as en_GB or es_ES),
 nor any locales for other languages (such as de_DE). The opposite may well be true for a device
 sold in Europe.
 <p>You can use <code>Locale.getDefault</code> to get an appropriate locale for the <i>user</i> of the
 device you're running on, or <code>Locale.getAvailableLocales</code> to get a list of all the locales
 available on the device you're running on.
 <a name="locale_data"><h3>Locale data</h3></a>
 <p>Note that locale data comes solely from ICU. User-supplied locale service providers (using
 the <code>java.text.spi</code> or <code>java.util.spi</code> mechanisms) are not supported.
 <p>Here are the versions of ICU (and the corresponding CLDR and Unicode versions) used in
 various Android releases:
 <table BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 <tr><td>cupcake/donut/eclair</td> <td>ICU 3.8</td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-5">CLDR 1.5</a></td>  <td><a href="http://www.unicode.org/versions/Unicode5.0.0/">Unicode 5.0</a></td></tr>
 <tr><td>froyo</td>                <td>ICU 4.2</td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-7">CLDR 1.7</a></td>  <td><a href="http://www.unicode.org/versions/Unicode5.1.0/">Unicode 5.1</a></td></tr>
 <tr><td>gingerbread/honeycomb</td><td>ICU 4.4</td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-8">CLDR 1.8</a></td>  <td><a href="http://www.unicode.org/versions/Unicode5.2.0/">Unicode 5.2</a></td></tr>
 <tr><td>ice cream sandwich</td>   <td>ICU 4.6</td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-9">CLDR 1.9</a></td>  <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
 <tr><td>jelly bean</td>           <td>ICU 4.8</td> <td><a href="http://cldr.unicode.org/index/downloads/cldr-2-0">CLDR 2.0</a></td>  <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
 <tr><td>later</td>                <td>ICU 49</td>  <td><a href="http://cldr.unicode.org/index/downloads/cldr-21">CLDR 21.0</a></td> <td><a href="http://www.unicode.org/versions/Unicode6.1.0/">Unicode 6.1</a></td></tr>
 </table>
 <a name="default_locale"><h3>Be wary of the default locale</h3></a>
 <p>Note that there are many convenience methods that automatically use the default locale, but
 using them may lead to subtle bugs.
 <p>The default locale is appropriate for tasks that involve presenting data to the user. In
 this case, you want to use the user's date/time formats, number
 formats, rules for conversion to lowercase, and so on. In this case, it's safe to use the
 convenience methods.
 <p>The default locale is <i>not</i> appropriate for machine-readable output. The best choice
 there is usually <code>Locale.US</code>&nbsp;&ndash; this locale is guaranteed to be available on all
 devices, and the fact that it has no surprising special cases and is frequently used (especially
 for computer-computer communication) means that it tends to be the most efficient choice too.
 <p>A common mistake is to implicitly use the default locale when producing output meant to be
 machine-readable. This tends to work on the developer's test devices (especially because so many
 developers use en_US), but fails when run on a device whose user is in a more complex locale.
 <p>For example, if you're formatting integers some locales will use non-ASCII decimal
 digits. As another example, if you're formatting floating-point numbers some locales will use
 <code>','</code> as the decimal point and <code>'.'</code> for digit grouping. That's correct for
 human-readable output, but likely to cause problems if presented to another
 computer (<code>Double.parseDouble</code> can't parse such a number, for example).
 You should also be wary of the <code>String.toLowerCase</code> and
 <code>String.toUpperCase</code> overloads that don't take a <code>Locale</code>: in Turkey, for example,
 the characters <code>'i'</code> and <code>'I'</code> won't be converted to <code>'I'</code> and <code>'i'</code>.
 This is the correct behavior for Turkish text (such as user input), but inappropriate for, say,
 HTTP headers.
 */
@interface JavaUtilLocale : NSObject < NSCopying, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Constructs a new <code>Locale</code> using the specified language.
 */
- (instancetype)initWithNSString:(NSString *)language;

/*!
 @brief Constructs a new <code>Locale</code> using the specified language and country codes.
 */
- (instancetype)initWithNSString:(NSString *)language
                    withNSString:(NSString *)country;

/*!
 @brief Constructs a new <code>Locale</code> using the specified language, country,
 and variant codes.
 */
- (instancetype)initWithNSString:(NSString *)language
                    withNSString:(NSString *)country
                    withNSString:(NSString *)variant;

- (id)clone;

/*!
 @brief Returns true if <code>object</code> is a locale with the same language,
 country and variant.
 */
- (jboolean)isEqual:(id)object;

/*!
 @brief Returns the system's installed locales.
 This array always includes <code>Locale.US</code>
 , and usually several others. Most locale-sensitive classes
 offer their own <code>getAvailableLocales</code> method, which should be
 preferred over this general purpose method.
 */
+ (IOSObjectArray *)getAvailableLocales;

/*!
 @brief Returns the country code for this locale, or <code>""</code> if this locale
 doesn't correspond to a specific country.
 */
- (NSString *)getCountry;

/*!
 @brief Returns the user's preferred locale.
 This may have been overridden for
 this process with <code>setDefault</code>.
 <p>Since the user's locale changes dynamically, avoid caching this value.
 Instead, use this method to look it up for each use.
 */
+ (JavaUtilLocale *)getDefault;

/*!
 @brief Equivalent to <code>getDisplayCountry(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayCountry;

/*!
 @brief Returns the name of this locale's country, localized to <code>locale</code>.
 Returns the empty string if this locale does not correspond to a specific
 country.
 */
- (NSString *)getDisplayCountryWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Equivalent to <code>getDisplayLanguage(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayLanguage;

/*!
 @brief Returns the name of this locale's language, localized to <code>locale</code>.
 If the language name is unknown, the language code is returned.
 */
- (NSString *)getDisplayLanguageWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Equivalent to <code>getDisplayName(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayName;

/*!
 @brief Returns this locale's language name, country name, and variant, localized
 to <code>locale</code>.
 The exact output form depends on whether this locale
 corresponds to a specific language, country and variant.
 <p>For example:
 <ul>
 <li><code>new Locale("en").getDisplayName(Locale.US)</code> -> <code>English</code>
 <li><code>new Locale("en", "US").getDisplayName(Locale.US)</code> -> <code>English (United States)</code>
 <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.US)</code> -> <code>English (United States,Computer)</code>
 <li><code>new Locale("en").getDisplayName(Locale.FRANCE)</code> -> <code>anglais</code>
 <li><code>new Locale("en", "US").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis)</code>
 <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis,informatique)</code>.
 </ul>
 */
- (NSString *)getDisplayNameWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the full variant name in the default <code>Locale</code> for the variant code of
 this <code>Locale</code>.
 If there is no matching variant name, the variant code is
 returned.
 */
- (NSString *)getDisplayVariant;

/*!
 @brief Returns the full variant name in the specified <code>Locale</code> for the variant code
 of this <code>Locale</code>.
 If there is no matching variant name, the variant code is
 returned.
 */
- (NSString *)getDisplayVariantWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the three-letter ISO 3166 country code which corresponds to the country
 code for this <code>Locale</code>.
 @throws MissingResourceException if there's no 3-letter country code for this locale.
 */
- (NSString *)getISO3Country;

/*!
 @brief Returns the three-letter ISO 639-2/T language code which corresponds to the language
 code for this <code>Locale</code>.
 @throws MissingResourceException if there's no 3-letter language code for this locale.
 */
- (NSString *)getISO3Language;

/*!
 @brief Returns an array of strings containing all the two-letter ISO 3166 country codes that can be
 used as the country code when constructing a <code>Locale</code>.
 */
+ (IOSObjectArray *)getISOCountries;

/*!
 @brief Returns an array of strings containing all the two-letter ISO 639-1 language codes that can be
 used as the language code when constructing a <code>Locale</code>.
 */
+ (IOSObjectArray *)getISOLanguages;

/*!
 @brief Returns the language code for this <code>Locale</code> or the empty string if no language
 was set.
 */
- (NSString *)getLanguage;

/*!
 @brief Returns the variant code for this <code>Locale</code> or an empty <code>String</code> if no variant
 was set.
 */
- (NSString *)getVariant;

- (NSUInteger)hash;

/*!
 @brief Overrides the default locale.
 This does not affect system configuration,
 and attempts to override the system-provided default locale may
 themselves be overridden by actual changes to the system configuration.
 Code that calls this method is usually incorrect, and should be fixed by
 passing the appropriate locale to each locale-sensitive method that's
 called.
 */
+ (void)setDefaultWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the string representation of this <code>Locale</code>.
 It consists of the
 language code, country code and variant separated by underscores.
 If the language is missing the string begins
 with an underscore. If the country is missing there are 2 underscores
 between the language and the variant. The variant cannot stand alone
 without a language and/or country code: in this case this method would
 return the empty string.
 <p>Examples: "en", "en_US", "_US", "en__POSIX", "en_US_POSIX"
 */
- (NSString *)description;

@end

J2OBJC_STATIC_INIT(JavaUtilLocale)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, CANADA_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA_FRENCH_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, CANADA_FRENCH_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINA_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, CHINA_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINESE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, CHINESE_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ENGLISH_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, ENGLISH_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRANCE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, FRANCE_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRENCH_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, FRENCH_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMAN_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, GERMAN_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMANY_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, GERMANY_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALIAN_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, ITALIAN_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALY_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, ITALY_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPAN_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, JAPAN_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPANESE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, JAPANESE_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREA_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, KOREA_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREAN_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, KOREAN_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_PRC_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, PRC_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ROOT_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, ROOT_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_SIMPLIFIED_CHINESE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, SIMPLIFIED_CHINESE_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TAIWAN_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, TAIWAN_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TRADITIONAL_CHINESE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, TRADITIONAL_CHINESE_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_UK_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, UK_, JavaUtilLocale *)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_US_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilLocale, US_, JavaUtilLocale *)

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_(JavaUtilLocale *self, NSString *language);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_(NSString *language) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_(NSString *language, NSString *country) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getAvailableLocales();

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getDefault();

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOCountries();

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOLanguages();

FOUNDATION_EXPORT void JavaUtilLocale_setDefaultWithJavaUtilLocale_(JavaUtilLocale *locale);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale)

#endif // _JavaUtilLocale_H_
