//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/LinkedHashMap.java
//

#ifndef _JavaUtilLinkedHashMap_H_
#define _JavaUtilLinkedHashMap_H_

#include "J2ObjC_header.h"
#include "java/util/HashMap.h"

@class JavaUtilLinkedHashMap_LinkedEntry;
@protocol JavaUtilIterator;
@protocol JavaUtilMap;
@protocol JavaUtilMap_Entry;

/*!
 @brief LinkedHashMap is an implementation of <code>Map</code> that guarantees iteration order.
 All optional operations are supported.
 <p>All elements are permitted as keys or values, including null.
 <p>Entries are kept in a doubly-linked list. The iteration order is, by default, the
 order in which keys were inserted. Reinserting an already-present key doesn't change the
 order. If the three argument constructor is used, and <code>accessOrder</code> is specified as
 <code>true</code>, the iteration will be in the order that entries were accessed.
 The access order is affected by <code>put</code>, <code>get</code>, and <code>putAll</code> operations,
 but not by operations on the collection views.
 <p>Note: the implementation of <code>LinkedHashMap</code> is not synchronized.
 If one thread of several threads accessing an instance modifies the map
 structurally, access to the map needs to be synchronized. For
 insertion-ordered instances a structural modification is an operation that
 removes or adds an entry. Access-ordered instances also are structurally
 modified by <code>put</code>, <code>get</code>, and <code>putAll</code> since these methods
 change the order of the entries. Changes in the value of an entry are not structural changes.
 <p>The <code>Iterator</code> created by calling the <code>iterator</code> method
 may throw a <code>ConcurrentModificationException</code> if the map is structurally
 changed while an iterator is used to iterate over the elements. Only the
 <code>remove</code> method that is provided by the iterator allows for removal of
 elements during iteration. It is not possible to guarantee that this
 mechanism works in all cases of unsynchronized concurrent modification. It
 should only be used for debugging purposes.
 */
@interface JavaUtilLinkedHashMap : JavaUtilHashMap {
 @public
  /*!
   @brief A dummy entry in the circular linked list of entries in the map.
   The first real entry is header.nxt, and the last is header.prv.
 If the map is empty, header.nxt == header && header.prv == header.
   */
  JavaUtilLinkedHashMap_LinkedEntry *header_;
}

#pragma mark Public

/*!
 @brief Constructs a new empty <code>LinkedHashMap</code> instance.
 */
- (instancetype)init;

/*!
 @brief Constructs a new <code>LinkedHashMap</code> instance with the specified
 capacity.
 @param initialCapacity
 the initial capacity of this map.
 @throws IllegalArgumentException
 when the capacity is less than zero.
 */
- (instancetype)initWithInt:(jint)initialCapacity;

/*!
 @brief Constructs a new <code>LinkedHashMap</code> instance with the specified
 capacity and load factor.
 @param initialCapacity
 the initial capacity of this map.
 @param loadFactor
 the initial load factor.
 @throws IllegalArgumentException
 when the capacity is less than zero or the load factor is
 less or equal to zero.
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor;

/*!
 @brief Constructs a new <code>LinkedHashMap</code> instance with the specified
 capacity, load factor and a flag specifying the ordering behavior.
 @param initialCapacity
 the initial capacity of this hash map.
 @param loadFactor
 the initial load factor.
 @param accessOrder
 <code>true</code> if the ordering should be done based on the last
 access (from least-recently accessed to most-recently
 accessed), and <code>false</code> if the ordering should be the
 order in which the entries were inserted.
 @throws IllegalArgumentException
 when the capacity is less than zero or the load factor is
 less or equal to zero.
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                withBoolean:(jboolean)accessOrder;

/*!
 @brief Constructs a new <code>LinkedHashMap</code> instance containing the mappings
 from the specified map.
 The order of the elements is preserved.
 @param map
 the mappings to add.
 */
- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)map;

- (void)clear;

/*!
 @brief This override is done for LinkedHashMap performance: iteration is cheaper
 via LinkedHashMap nxt links.
 */
- (jboolean)containsValueWithId:(id)value;

/*!
 @brief Returns the eldest entry in the map, or <code>null</code> if the map is empty.
 */
- (id<JavaUtilMap_Entry>)eldest;

/*!
 @brief Returns the value of the mapping with the specified key.
 @param key
 the key.
 @return the value of the mapping with the specified key, or <code>null</code>
 if no mapping for the specified key is found.
 */
- (id)getWithId:(id)key;

#pragma mark Protected

- (jboolean)removeEldestEntryWithJavaUtilMap_Entry:(id<JavaUtilMap_Entry>)eldest;

#pragma mark Package-Private

/*!
 @brief Evicts eldest entry if instructed, creates a new entry and links it in
 as head of linked list.
 This method should call constructorNewEntry
 (instead of duplicating code) if the performance of your VM permits.
 <p>It may seem strange that this method is tasked with adding the entry
 to the hash table (which is properly the province of our superclass).
 The alternative of passing the "next" link in to this method and
 returning the newly created element does not work! If we remove an
 (eldest) entry that happens to be the first entry in the same bucket
 as the newly created entry, the "next" link would become invalid, and
 the resulting hash table corrupt.
 Modified to avoid extra retain/autorelease calls.
 */
- (void)addNewEntryWithId:(id)key
                   withId:(id)value
                  withInt:(jint)hash_
                  withInt:(jint)index;

- (void)addNewEntryForNullKeyWithId:(id)value;

/*!
 @brief As above, but without eviction.
 This native method has a modified contract from the original version.
 It must return a retained entry object. And it must avoid retaining the
 "first" parameter when setting it to the "next" field of the new entry.
 */
- (JavaUtilHashMap_HashMapEntry *)constructorNewRetainedEntryWithId:(id)key
                                                             withId:(id)value
                                                            withInt:(jint)hash_
                                   withJavaUtilHashMap_HashMapEntry:(JavaUtilHashMap_HashMapEntry *)next;

- (void)init__ OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newEntryIterator OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newKeyIterator OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newValueIterator OBJC_METHOD_FAMILY_NONE;

- (void)postRemoveWithJavaUtilHashMap_HashMapEntry:(JavaUtilHashMap_HashMapEntry *)e;

- (void)preModifyWithJavaUtilHashMap_HashMapEntry:(JavaUtilHashMap_HashMapEntry *)e;


@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLinkedHashMap)

J2OBJC_FIELD_SETTER(JavaUtilLinkedHashMap, header_, JavaUtilLinkedHashMap_LinkedEntry *)

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_init(JavaUtilLinkedHashMap *self);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_(JavaUtilLinkedHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_withFloat_(JavaUtilLinkedHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_withFloat_withBoolean_(JavaUtilLinkedHashMap *self, jint initialCapacity, jfloat loadFactor, jboolean accessOrder);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_withFloat_withBoolean_(jint initialCapacity, jfloat loadFactor, jboolean accessOrder) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithJavaUtilMap_(JavaUtilLinkedHashMap *self, id<JavaUtilMap> map);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithJavaUtilMap_(id<JavaUtilMap> map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLinkedHashMap)

/*!
 @brief LinkedEntry adds nxt/prv double-links to plain HashMapEntry.
 */
@interface JavaUtilLinkedHashMap_LinkedEntry : JavaUtilHashMap_HashMapEntry {
 @public
  __weak JavaUtilLinkedHashMap_LinkedEntry *nxt_;
  __weak JavaUtilLinkedHashMap_LinkedEntry *prv_;
}

#pragma mark Package-Private

/*!
 @brief Create the header entry
 */
- (instancetype)init;

/*!
 @brief Create a normal entry
 */
- (instancetype)initWithId:(id)key
                    withId:(id)value
                   withInt:(jint)hash_
withJavaUtilHashMap_HashMapEntry:(JavaUtilHashMap_HashMapEntry *)next
withJavaUtilLinkedHashMap_LinkedEntry:(JavaUtilLinkedHashMap_LinkedEntry *)nxt
withJavaUtilLinkedHashMap_LinkedEntry:(JavaUtilLinkedHashMap_LinkedEntry *)prv;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLinkedHashMap_LinkedEntry)

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_LinkedEntry_init(JavaUtilLinkedHashMap_LinkedEntry *self);

FOUNDATION_EXPORT JavaUtilLinkedHashMap_LinkedEntry *new_JavaUtilLinkedHashMap_LinkedEntry_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_LinkedEntry_initWithId_withId_withInt_withJavaUtilHashMap_HashMapEntry_withJavaUtilLinkedHashMap_LinkedEntry_withJavaUtilLinkedHashMap_LinkedEntry_(JavaUtilLinkedHashMap_LinkedEntry *self, id key, id value, jint hash_, JavaUtilHashMap_HashMapEntry *next, JavaUtilLinkedHashMap_LinkedEntry *nxt, JavaUtilLinkedHashMap_LinkedEntry *prv);

FOUNDATION_EXPORT JavaUtilLinkedHashMap_LinkedEntry *new_JavaUtilLinkedHashMap_LinkedEntry_initWithId_withId_withInt_withJavaUtilHashMap_HashMapEntry_withJavaUtilLinkedHashMap_LinkedEntry_withJavaUtilLinkedHashMap_LinkedEntry_(id key, id value, jint hash_, JavaUtilHashMap_HashMapEntry *next, JavaUtilLinkedHashMap_LinkedEntry *nxt, JavaUtilLinkedHashMap_LinkedEntry *prv) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLinkedHashMap_LinkedEntry)

#endif // _JavaUtilLinkedHashMap_H_
